//
//  UIScrollView+CMTExtension_TableScrollView.m
//  MedicalForum
//
//  Created by fenglei on 15/7/21.
//  Copyright (c) 2015å¹´ CMT. All rights reserved.
//

#import "UIScrollView+CMTExtension_TableScrollView.h"
#import "CMTReplyListWrapCell.h"
#import <objc/runtime.h>

static const NSString *CMTTableScrollViewDataSourceAssociatedKey = @"CMTTableScrollViewDataSourceAssociatedKey";
static const NSString *CMTTableScrollViewDelegateAssociatedKey = @"CMTTableScrollViewDelegateAssociatedKey";
static const NSString *CMTTableScrollViewDequeuedCellAssociatedKey = @"CMTTableScrollViewDequeuedCellAssociatedKey";
static const NSString *CMTTableScrollViewBlackCoverViewAssociatedKey = @"CMTTableScrollViewBlackCoverViewAssociatedKey";
static const NSString *CMTTableScrollViewPlaceholderViewAssociatedKey = @"CMTTableScrollViewPlaceholderViewAssociatedKey";
static const NSString *CMTTableScrollViewFrameOfCellsAssociatedKey = @"CMTTableScrollViewFrameOfCellsAssociatedKey";
static const NSString *CMTTableScrollViewIndexsOfVisibleCellsAssociatedKey = @"CMTTableScrollViewIndexsOfVisibleCellsAssociatedKey";
static const NSString *CMTTableScrollViewNumberOfCellsAssociatedKey = @"CMTTableScrollViewNumberOfCellsAssociatedKey";
static const NSString *CMTTableScrollViewHeaderHeightAssociatedKey = @"CMTTableScrollViewHeaderHeightAssociatedKey";
static const NSString *CMTTableScrollViewFixedViewHeightAssociatedKey = @"CMTTableScrollViewFixedViewHeightAssociatedKey";
static const NSString *CMTTableScrollViewAccessoryHeightAssociatedKey = @"CMTTableScrollViewAccessoryHeightAssociatedKey";
static const NSString *CMTTableScrollViewCurrentOffsetYAssociatedKey = @"CMTTableScrollViewCurrentOffsetYAssociatedKey";
static const NSString *CMTTableScrollViewFrameHeightAssociatedKey = @"CMTTableScrollViewFrameHeightAssociatedKey";
static const NSString *CMTTableScrollViewTopInsetAssociatedKey = @"CMTTableScrollViewTopInsetAssociatedKey";
static const NSString *CMTTableScrollViewBottomInsetAssociatedKey = @"CMTTableScrollViewBottomInsetAssociatedKey";
static const NSString *CMTTableScrollViewLastCoveredHeightAssociatedKey = @"CMTTableScrollViewLastCoveredHeightAssociatedKey";
static const NSString *CMTTableScrollViewAfterReloadAssociatedKey = @"CMTTableScrollViewAfterReloadAssociatedKey";
static const NSString *CMTTableScrollViewLostCellsAssociatedKey = @"CMTTableScrollViewLostCellsAssociatedKey";
static const NSString *CMTTableScrollViewCellLostExpectedAssociatedKey = @"CMTTableScrollViewCellLostExpectedAssociatedKey";

static const NSUInteger CMTTableScrollViewBaseCellTag = 1000;

@interface CMTTableScrollViewCellTapGesture : UITapGestureRecognizer <UIGestureRecognizerDelegate>
@property (nonatomic, copy) NSString *gestureName;
@end
@implementation CMTTableScrollViewCellTapGesture
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer {
    if ([gestureRecognizer.view isKindOfClass:[UITableViewCell class]] == NO) {
        return YES;
    }
    
    UITableViewCell *cell = (UITableViewCell *)gestureRecognizer.view;
    CGPoint location =  [gestureRecognizer locationInView:cell];
    
    BOOL locationInControl = NO;
    for (UIView *subView in cell.contentView.subviews) {
        if ([subView isKindOfClass:[UIControl class]]) {
            if (CGRectContainsPoint(subView.frame, location)) {
                locationInControl = YES;
                break;
            }
        }
    }
    
    return !locationInControl;
}
@end

@implementation UIScrollView (CMTExtension_TableScrollView)

#pragma mark - Property

- (id<CMTTableScrollViewDataSource>)tableScrollViewDataSource {
    return objc_getAssociatedObject(self, &CMTTableScrollViewDataSourceAssociatedKey);
}

- (void)setTableScrollViewDataSource:(id<CMTTableScrollViewDataSource>)tableScrollViewDataSource {
    if ([self.tableScrollViewDataSource isEqual:tableScrollViewDataSource]) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewDataSourceAssociatedKey, tableScrollViewDataSource, OBJC_ASSOCIATION_ASSIGN);
}

- (id<CMTTableScrollViewDelegate>)tableScrollViewDelegate {
    return objc_getAssociatedObject(self, &CMTTableScrollViewDelegateAssociatedKey);
}

- (void)setTableScrollViewDelegate:(id<CMTTableScrollViewDelegate>)tableScrollViewDelegate {
    if ([self.tableScrollViewDelegate isEqual:tableScrollViewDelegate]) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewDelegateAssociatedKey, tableScrollViewDelegate, OBJC_ASSOCIATION_ASSIGN);
}

- (UITableViewCell *)dequeuedCell {
    return objc_getAssociatedObject(self, &CMTTableScrollViewDequeuedCellAssociatedKey);
}

- (void)setDequeuedCell:(UITableViewCell *)dequeuedCell {
    if ([self.dequeuedCell isEqual:dequeuedCell]) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewDequeuedCellAssociatedKey, dequeuedCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (UIView *)blackCoverView {
    return objc_getAssociatedObject(self, &CMTTableScrollViewBlackCoverViewAssociatedKey);
}

- (void)setBlackCoverView:(UIView *)blackCoverView {
    if ([self.blackCoverView isEqual:blackCoverView]) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewBlackCoverViewAssociatedKey, blackCoverView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (UIView *)placeholderView {
    return objc_getAssociatedObject(self, &CMTTableScrollViewPlaceholderViewAssociatedKey);
}

- (void)setPlaceholderView:(UIView *)placeholderView {
    if ([self.placeholderView isEqual:placeholderView]) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewPlaceholderViewAssociatedKey, placeholderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (NSMutableDictionary *)frameOfCells {
    return objc_getAssociatedObject(self, &CMTTableScrollViewFrameOfCellsAssociatedKey);
}

- (void)setFrameOfCells:(NSMutableDictionary *)frameOfCells {
    if ([self.frameOfCells isEqual:frameOfCells]) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewFrameOfCellsAssociatedKey, frameOfCells, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (NSMutableArray *)indexsOfVisibleCells {
    return objc_getAssociatedObject(self, &CMTTableScrollViewIndexsOfVisibleCellsAssociatedKey);
}

- (void)setIndexsOfVisibleCells:(NSMutableArray *)indexsOfVisibleCells {
    if ([self.indexsOfVisibleCells isEqual:indexsOfVisibleCells]) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewIndexsOfVisibleCellsAssociatedKey, indexsOfVisibleCells, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (NSUInteger)numberOfCells {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewNumberOfCellsAssociatedKey) unsignedIntegerValue];
}

- (void)setNumberOfCells:(NSUInteger)numberOfCells {
    if (self.numberOfCells == numberOfCells) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewNumberOfCellsAssociatedKey, [NSNumber numberWithUnsignedInteger:numberOfCells], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (CGFloat)headerHeight {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewHeaderHeightAssociatedKey) floatValue];
}

- (void)setHeaderHeight:(CGFloat)headerHeight {
    if (self.headerHeight == headerHeight) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewHeaderHeightAssociatedKey, [NSNumber numberWithFloat:headerHeight], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (CGFloat)fixedViewHeight {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewFixedViewHeightAssociatedKey) floatValue];
}

- (void)setFixedViewHeight:(CGFloat)fixedViewHeight {
    if (self.fixedViewHeight == fixedViewHeight) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewFixedViewHeightAssociatedKey, [NSNumber numberWithFloat:fixedViewHeight], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (CGFloat)accessoryHeight {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewAccessoryHeightAssociatedKey) floatValue];
}

- (void)setAccessoryHeight:(CGFloat)accessoryHeight {
    if (self.accessoryHeight == accessoryHeight) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewAccessoryHeightAssociatedKey, [NSNumber numberWithFloat:accessoryHeight], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (CGFloat)currentOffsetY {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewCurrentOffsetYAssociatedKey) floatValue];
}

- (void)setCurrentOffsetY:(CGFloat)currentOffsetY {
    if (self.currentOffsetY == currentOffsetY) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewCurrentOffsetYAssociatedKey, [NSNumber numberWithFloat:currentOffsetY], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (CGFloat)frameHeight {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewFrameHeightAssociatedKey) floatValue];
}

- (void)setFrameHeight:(CGFloat)frameHeight {
    if (self.frameHeight == frameHeight) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewFrameHeightAssociatedKey, [NSNumber numberWithFloat:frameHeight], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (CGFloat)topInset {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewTopInsetAssociatedKey) floatValue];
}

- (void)setTopInset:(CGFloat)topInset {
    if (self.topInset == topInset) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewTopInsetAssociatedKey, [NSNumber numberWithFloat:topInset], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (CGFloat)bottomInset {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewBottomInsetAssociatedKey) floatValue];
}

- (void)setBottomInset:(CGFloat)bottomInset {
    if (self.bottomInset == bottomInset) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewBottomInsetAssociatedKey, [NSNumber numberWithFloat:bottomInset], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (CGFloat)lastCoveredHeight {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewLastCoveredHeightAssociatedKey) floatValue];
}

- (void)setLastCoveredHeight:(CGFloat)lastCoveredHeight {
    if (self.lastCoveredHeight == lastCoveredHeight) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewLastCoveredHeightAssociatedKey, [NSNumber numberWithFloat:lastCoveredHeight], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (BOOL)afterReload {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewAfterReloadAssociatedKey) boolValue];
}

- (void)setAfterReload:(BOOL)afterReload {
    if (self.afterReload == afterReload) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewAfterReloadAssociatedKey, [NSNumber numberWithBool:afterReload], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (BOOL)lostCells {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewLostCellsAssociatedKey) boolValue];
}

- (void)setLostCells:(BOOL)lostCells {
    if (self.lostCells == lostCells) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewLostCellsAssociatedKey, [NSNumber numberWithBool:lostCells], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (BOOL)cellLostExpected {
    return [objc_getAssociatedObject(self, &CMTTableScrollViewCellLostExpectedAssociatedKey) boolValue];
}

- (void)setCellLostExpected:(BOOL)cellLostExpected {
    if (self.cellLostExpected == cellLostExpected) {
        return;
    }
    
    objc_setAssociatedObject(self, &CMTTableScrollViewCellLostExpectedAssociatedKey, [NSNumber numberWithBool:cellLostExpected], OBJC_ASSOCIATION_COPY_NONATOMIC);
}

#pragma mark - Initialize

- (void)initTableScrollView {
    
    // UI
    self.dequeuedCell = nil;
    self.blackCoverView = nil;
    self.placeholderView = nil;
    
    // data
    self.frameOfCells = [[NSMutableDictionary alloc] init];
    self.indexsOfVisibleCells = [[NSMutableArray alloc] init];
    self.numberOfCells = 0;
    self.headerHeight = 0.0;
    self.fixedViewHeight = 0.0;
    self.accessoryHeight = 0.0;
    self.currentOffsetY = 0.0;
    self.frameHeight = 0.0;
    self.topInset = 0.0;
    self.bottomInset = 0.0;
    self.lastCoveredHeight = 0.0;
    self.lostCells = NO;
    self.cellLostExpected = NO;
}

#pragma mark - Control

- (void)reloadDataWithHeaderHeight:(CGFloat)headerHeight
                   fixedViewHeight:(CGFloat)fixedViewHeight
                   accessoryHeight:(CGFloat)accessoryHeight
                       frameHeight:(CGFloat)frameHeight
                          topInset:(CGFloat)topInset
                       bottomInset:(CGFloat)bottomInset {
    
    self.afterReload = YES;
    self.headerHeight = headerHeight;
    self.fixedViewHeight = fixedViewHeight;
    self.accessoryHeight = accessoryHeight;
    self.currentOffsetY = 0.0;
    self.frameHeight = frameHeight;
    self.topInset = topInset;
    self.bottomInset = bottomInset;
    self.lastCoveredHeight = headerHeight;
    
    [self reloadScrollData];
}

- (void)reloadScrollData {
    
    [self removeAllCells];
    [self.frameOfCells removeAllObjects];
    [self.indexsOfVisibleCells removeAllObjects];
    
    [self initializeFrameOfCells];
    [self configScrollContent];
    [self initializeCells];
}

- (void)scrollToCellAtIndex:(NSInteger)index {
    // this is the case when cell lost is expected one would scroll from first view to 100th view...fast scrolling looses cell.
    self.cellLostExpected = YES;
    
    [self scrollRectToVisible:[self frameOfCellAtIndex:index] animated:YES];
}

- (void)removeAllCells {
    for (UITableViewCell *cell in self.subviews) {
        if ([cell isKindOfClass:[UITableViewCell class]]) {
            [cell removeFromSuperview];
        }
    }
}

// åå§ååæ 
- (void)initializeFrameOfCells {
    // è·åcellæ»æ°
    if ([self.tableScrollViewDataSource respondsToSelector:@selector(numberOfCellsInTableScrollView:)]) {
        self.numberOfCells = [self.tableScrollViewDataSource numberOfCellsInTableScrollView:self];
    }
    if (self.numberOfCells <= 0) {
        return;
    }
    
    // è®¡ç®ç¬¬ä¸ä¸ªcellçy
    CGFloat frameYOfCell = self.headerHeight + self.fixedViewHeight + self.accessoryHeight;
    
    // éåcellçindex è·ådataSource -heightForCellAtIndex è®¡ç®cellçframe
    for (NSInteger index = 0; index < self.numberOfCells; index++) {
        
        CGFloat cellHeight = 0.0;
        if ([self.tableScrollViewDataSource respondsToSelector:@selector(tableScrollView:heightForCellAtIndex:)]) {
            cellHeight = [self.tableScrollViewDataSource tableScrollView:self heightForCellAtIndex:index];
        }
        
        // è®¾ç½®ç¸åºcellçframe
        self.frameOfCells[[NSNumber numberWithInteger:index]] = [NSValue valueWithCGRect:
                                                                 CGRectMake(0.0,
                                                                            frameYOfCell,
                                                                            self.bounds.size.width,
                                                                            cellHeight)];
        
        frameYOfCell += cellHeight;
    }
    
    // æåä¸ä¸ªcellè¦ççé«åº¦
    self.lastCoveredHeight = frameYOfCell;
}

// è°æ´æ»å¨åºå
// numberOfCellsä¸º0æ¶ ä¹éè¦è°æ´
- (void)configScrollContent {
    
    // å®¹å¨(æç« åå®¹+è¯è®ºåè¡¨)é«åº¦
    CGFloat webViewHeight = self.frameHeight;
    // å®¹å¨é¡¶é¨contentInset
    CGFloat webViewTopInset = self.topInset;
    // å®¹å¨åºé¨contentInset
    CGFloat webViewBottomInset = self.bottomInset;
    // ä¸è¬ä¸ºå¯¼èªæ åºé¨è³å±å¹åºé¨é«åº¦
    CGFloat webViewContainerHeight = webViewHeight - webViewTopInset;
    // ä¸è¬ä¸ºå¯¼èªæ åºé¨ä¸è¯è®ºåå¤æ¡é¡¶é¨ä¹é´é«åº¦
    CGFloat webViewDisplayHeight = webViewContainerHeight - webViewBottomInset;
    
    // æç« åå®¹é«åº¦
    CGFloat postDetailHeight = self.headerHeight;
    
    // è¯è®ºä¸æ¹åºå®è§å¾(å¦è¯è®ºåè¡¨é¡¶é¨è§å¾)é«åº¦
    CGFloat replyFixedViewHeight = self.fixedViewHeight;
    // è¯è®ºä¸æ¹é¢å¤è§å¾(å¦ç¹å»å è½½)é«åº¦
    CGFloat replyAccessoryHeight = self.accessoryHeight;
    // æ è¯è®ºplaceholderè§å¾é«åº¦
    CGFloat replyPlaceholderViewHeight = self.placeholderView.height;
    // ææcellé«åº¦
    CGFloat replyCellsHeight = 0;
    if (self.numberOfCells > 0) {
        replyCellsHeight = self.lastCoveredHeight - (postDetailHeight + replyFixedViewHeight + replyAccessoryHeight);
    }
    
    // é»è®¤è¯è®ºåè¡¨æ»é«åº¦("å¨é¨è¯è®º"æç¤ºé«åº¦+ç¹å»å·æ°é«åº¦+ææcellé«åº¦)
    CGFloat replyTotalHeight = replyFixedViewHeight + replyAccessoryHeight + replyCellsHeight;
    // "å¨é¨è¯è®º"æç¤ºå§ç»æ¾ç¤º
    // å¦æ(ç¹å»å·æ°é«åº¦+ææcellé«åº¦)ä¸º0, åç¹å»å·æ°ä¸è¯è®ºcelléè, æ¾ç¤ºplaceholder
    if (replyAccessoryHeight + replyCellsHeight == 0.0) {
        // è¯è®ºåè¡¨æ»é«åº¦æ¿æ¢ä¸º("å¨é¨è¯è®º"æç¤ºé«åº¦+placeholderè§å¾é«åº¦)
        replyTotalHeight = replyFixedViewHeight + replyPlaceholderViewHeight;
    }
    
    CMTLog(@"webViewHeight: %g", webViewHeight);
    
    CMTLog(@"postDetailHeight: %g", postDetailHeight);
    
    CMTLog(@"replyFixedViewHeight: %g", replyFixedViewHeight);
    
    CMTLog(@"replyAccessoryHeight: %g", replyAccessoryHeight);
    
    CMTLog(@"replyCellsHeight: %g", replyCellsHeight);
    
    CMTLog(@"replyPlaceholderViewHeight: %g", replyPlaceholderViewHeight);
    
    CMTLog(@"replyTotalHeight: %g", replyTotalHeight);
    
    CMTLog(@"\nbefore\nwebView.scrollView.contentSize: %@\nwebView.scrollView.contentInset: %@",
           NSStringFromCGSize(self.contentSize),
           NSStringFromUIEdgeInsets(self.contentInset));
    
    UIEdgeInsets contentInset = UIEdgeInsetsMake(webViewTopInset, 0.0, webViewBottomInset, 0.0);
    
    // åå®¹é«åº¦å°äºdisplayHeight
    if (postDetailHeight < webViewDisplayHeight) {
        CGFloat replyTotalHeightAdd = replyTotalHeight - (webViewDisplayHeight - postDetailHeight);
        // è¯è®ºé«åº¦å°äºdisplayHeight
        // ä½¿ç¨contentInset åç¼©webView.scrollView.contentSize.height
        if (replyTotalHeight < webViewDisplayHeight) {
            contentInset.bottom = webViewContainerHeight - postDetailHeight + (replyTotalHeightAdd > 0.0 ? replyTotalHeightAdd : 0.0);
            self.contentInset = contentInset;
            self.contentSize = CGSizeMake(self.width, postDetailHeight);
        }
        // è¯è®ºé«åº¦å¤§äºç­äºdisplayHeight
        // å¦æä½¿ç¨contentInset æ æ³åç¼©webView.scrollView.contentSize.height
        // webView.scrollView.contentSize.heightä¼èªå¨æ©å±å°displayHeight
        // æä»¥ç´æ¥æ©å±contentSize, contentInsetä¸ºé»è®¤çCMTReplyViewDefaultHeight
        else {
            self.contentInset = contentInset;
            self.contentSize = CGSizeMake(self.width, webViewDisplayHeight + replyTotalHeightAdd);
        }
    }
    // åå®¹é«åº¦å¨displayHeightä¸webViewHeightä¹é´
    else if (webViewDisplayHeight <= postDetailHeight && postDetailHeight <= webViewHeight) {
        // è¯è®ºé«åº¦
        contentInset.bottom = webViewBottomInset + replyTotalHeight;
        self.contentInset = contentInset;
        
        // æ­¤æ¶webView.scrollView.contentSize.heightæ»æ¯ç­äºwebViewHeight
        // ä½å®éwebViewå±ç°åå®¹é«åº¦ä¸ºpostDetailHeight
        // ç¬¬ä¸æ¬¡è¿å¥è¯¦æé¡µwebViewå±ç°åå®¹é«åº¦ææ¶ä¼æ©å±å°webViewHeight, æ©å±åºåä¸ºé»è²
        // æä»¥å¼ºå¶è®¾å®webView.scrollView.contentSize.heightä¸ºpostDetailHeight
        self.contentSize = CGSizeMake(self.width, postDetailHeight);
    }
    // åå®¹é«åº¦å¤§äºcontainerHeight
    else {
        contentInset.bottom = webViewBottomInset + replyTotalHeight;
        self.contentInset = contentInset;
        self.contentSize = self.contentSize;
    }
    
    CMTLog(@"\nafter\nwebView.scrollView.contentSize: %@\nwebView.scrollView.contentInset: %@",
           NSStringFromCGSize(self.contentSize),
           NSStringFromUIEdgeInsets(self.contentInset));
}

// åå§åcell
- (void)initializeCells {
    
    // blackCoverView è¦çUIWebViewçé»è²åºå
    if (self.blackCoverView == nil) {
        self.blackCoverView = [[UIView alloc] initWithFrame:CGRectMake(0.0, 0.0, self.bounds.size.width, self.frameHeight)];
        self.blackCoverView.backgroundColor = COLOR(c_fafafa);
        UIView *verticalScrollIndicator = [self valueForKey:@"verticalScrollIndicator"];
        if (verticalScrollIndicator == nil) {
            [self addSubview:self.blackCoverView];
        }
        else {
            [self insertSubview:self.blackCoverView belowSubview:verticalScrollIndicator];
        }
    }
    // blackCoverViewçyä¸ç¬¬ä¸ä¸ªcellçyç¸ç­
    self.blackCoverView.top = self.headerHeight + self.fixedViewHeight + self.accessoryHeight;
    
    // placeholderView
    [self.placeholderView removeFromSuperview];
    // æ cell
    if (self.numberOfCells == 0) {
        // å¯¹åº -configScrollContentæ¹æ³ä¸­ è¯è®ºåè¡¨æ»é«åº¦ä¸º0
        if (self.accessoryHeight == 0.0) {
            // å è½½placeholderView
            self.placeholderView.top = self.headerHeight + self.fixedViewHeight;
            [self insertSubview:self.placeholderView aboveSubview:self.blackCoverView];
        }
    }
    
    // æcell å·æ°cell
    for (NSInteger index = 0; index < self.numberOfCells; index++) {
        
        // æ£æ¥æå®indexçcellæ¯å¦å¯è§
        CGRect frameOfVisibleCell = [self frameOfVisibleCellAtIndex:index];
        if (CGRectEqualToRect(frameOfVisibleCell, CGRectZero) == NO) {
            
            // è·åcell
            UITableViewCell *visibleCell = nil;
            if ([self.tableScrollViewDataSource respondsToSelector:@selector(tableScrollView:cellAtIndex:)]) {
                visibleCell = [self.tableScrollViewDataSource tableScrollView:self cellAtIndex:index];
            }
            if (visibleCell == nil) {
                CMTLogError(@"Get VisibleCell Error: VisibleCell is nil");
                return;
            }
            
            // è®¾ç½®frame
            visibleCell.frame = frameOfVisibleCell;
            visibleCell.tag = CMTTableScrollViewBaseCellTag + index;
            
            // æ£æ¥æ¯å¦éå¤
            // tagç¸å åindexç¸å åframeç¸å
            // å¦æéå¤ ä¸ç¨å¤ç
            if ([self viewWithTag:visibleCell.tag] == nil) {
                
                // æ·»å cell
                [self insertSubview:visibleCell aboveSubview:self.blackCoverView];
                
                // æ·»å cellç¹å»æå¿
                if (visibleCell.gestureRecognizers.count > 0) {
                    for (UIGestureRecognizer *gestureRecognizer in visibleCell.gestureRecognizers) {
                        gestureRecognizer.delegate = nil;
                        [visibleCell removeGestureRecognizer:gestureRecognizer];
                    }
                }
                if ([visibleCell isKindOfClass:[CMTReplyListWrapCell class]] == NO) {
                    CMTTableScrollViewCellTapGesture *tapGestureRecognizer = [[CMTTableScrollViewCellTapGesture alloc] initWithTarget:self action:@selector(handleTap:)];
                    tapGestureRecognizer.delegate = tapGestureRecognizer;
                    [visibleCell addGestureRecognizer:tapGestureRecognizer];
                }
            }
            
            // è°ç¨willDisplayCell
            if ([self.tableScrollViewDelegate respondsToSelector:@selector(tableScrollView:willDisplayCell:atIndex:)]) {
                [self.tableScrollViewDelegate tableScrollView:self willDisplayCell:visibleCell atIndex:index];
            }
            
            // æ´æ°indexsOfVisibleCells
            [self.indexsOfVisibleCells addObject:[NSNumber numberWithInteger:index]];
            NSSortDescriptor *sortDesc = [[NSSortDescriptor alloc] initWithKey:@"" ascending:YES];
            [self.indexsOfVisibleCells sortUsingDescriptors:[NSArray arrayWithObject:sortDesc]];
        }
    }
}

#pragma mark - Data

// å¦ææå®indexçcellå½åå¯è§, è¿åå¶frame
// å¦å, è¿åCGRectZero
- (CGRect)frameOfVisibleCellAtIndex:(NSInteger)index {
    CGRect frameOfCell = [self frameOfCellAtIndex:index];
    
    if (CGRectIntersectsRect(self.bounds, frameOfCell) == YES) {
        
        return frameOfCell;
    }
    
    return CGRectZero;
}

- (CGRect)frameOfCellAtIndex:(NSInteger)index {
    return [self.frameOfCells[[NSNumber numberWithInteger:index]] CGRectValue];
}

- (NSArray *)indexsForVisibleCells {
    return [NSArray arrayWithArray:self.indexsOfVisibleCells];
}

#pragma mark - ReCycle

- (UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier {
    // å¤æ­dequeuedCellæ¯å¦å­å¨
    UITableViewCell *dequeuedCell = self.dequeuedCell;
    self.dequeuedCell = nil;
    
    if ([dequeuedCell.reuseIdentifier isEqualToString:identifier]) {
        if (dequeuedCell != nil) {
            // å¦ædequeuedCellå­å¨ ç´æ¥è¿å
            return dequeuedCell;
        }
    }
    
    // dequeuedCellä¸å­å¨ è¿åä¸ä¸ªä¸åºæ¾ç¤ºä½ä»å¨UIScrollViewä¸çcell
    for (UITableViewCell *cell in [self subviews]) {
        if ([cell isKindOfClass:[UITableViewCell class]]) {
            if ([cell.reuseIdentifier isEqualToString:identifier]) {
                if (CGRectIntersectsRect(self.bounds, cell.frame) == NO) {
                    
                    return cell;
                }
            }
        }
    }
    
    return nil;
}

- (void)inqueueReusableCellWithForwardDirection:(BOOL)forwardDirection {
    NSInteger nextIndex;
    NSInteger previousIndex;
    
    // å½åæå¯è§cell
    if ([self.indexsOfVisibleCells count] > 0) {
        
        // å¨ææå¯è§cellä¹åæ·»å æ°cell
        if (forwardDirection == YES) {
            nextIndex = [[self.indexsOfVisibleCells lastObject] integerValue] + 1;
            previousIndex = [[self.indexsOfVisibleCells objectAtIndex:0] integerValue];
            
        }
        // å¨ææå¯è§cellä¹åæ·»å æ°cell
        else {
            nextIndex = [[self.indexsOfVisibleCells objectAtIndex:0] integerValue] - 1;
            previousIndex = [[self.indexsOfVisibleCells lastObject] integerValue];
        }
        
        // nextIndexæªè¶ç (è¶ççæ æ°æ®, ä¸ç¨æ¾ç¤º)
        if (-1 < nextIndex && nextIndex < self.numberOfCells) {
            
            // nextIndexæå®çcellä¸ºå¯è§cell (ä¸å¯è§cellä¸ç¨æ¾ç¤º)
            CGRect frameOfCellAtNextIndex = [self frameOfCellAtIndex:nextIndex];
            if (CGRectIntersectsRect(self.bounds, frameOfCellAtNextIndex) == YES) {
                
                // indexsOfVisibleCellsä¸åå«nextIndex (é¿åéå¤?)
                if ([self.indexsOfVisibleCells containsObject:[NSNumber numberWithInteger:nextIndex]] == NO) {
                    
                    NSInteger insertIndex = forwardDirection ? [self.indexsOfVisibleCells count] : 0;
                    [self.indexsOfVisibleCells insertObject:[NSNumber numberWithInteger:nextIndex] atIndex:insertIndex];
                    
                    UITableViewCell *cell = [self.tableScrollViewDataSource tableScrollView:self cellAtIndex:nextIndex];
                    cell.frame = frameOfCellAtNextIndex;
                    cell.tag = CMTTableScrollViewBaseCellTag + nextIndex;
                    
                    if ([self viewWithTag:cell.tag] == nil) {
                        
                        // æ·»å cell
                        [self insertSubview:cell aboveSubview:self.blackCoverView];
                        
                        // æ·»å cellç¹å»æå¿
                        if (cell.gestureRecognizers.count > 0) {
                            for (UIGestureRecognizer *gestureRecognizer in cell.gestureRecognizers) {
                                gestureRecognizer.delegate = nil;
                                [cell removeGestureRecognizer:gestureRecognizer];
                            }
                        }
                        if ([cell isKindOfClass:[CMTReplyListWrapCell class]] == NO) {
                            CMTTableScrollViewCellTapGesture *tapGestureRecognizer = [[CMTTableScrollViewCellTapGesture alloc] initWithTarget:self action:@selector(handleTap:)];
                            tapGestureRecognizer.delegate = tapGestureRecognizer;
                            [cell addGestureRecognizer:tapGestureRecognizer];
                        }
                    }
                    
                    if ([self.tableScrollViewDelegate respondsToSelector:@selector(tableScrollView:willDisplayCell:atIndex:)]) {
                        [self.tableScrollViewDelegate tableScrollView:self willDisplayCell:cell atIndex:nextIndex];
                    }
                }
            }
        }
        
        // ååé¡¶ç«¯cellå¦ä¸å¯è§
        CGRect frameOfCellAtPreviousIndex = [self frameOfCellAtIndex:previousIndex];
        if (CGRectIntersectsRect(self.bounds, frameOfCellAtPreviousIndex) == NO) {
            
            // ä»indexsOfVisibleCellsä¸­ç§»é¤
            [self.indexsOfVisibleCells removeObject:[NSNumber numberWithInteger:previousIndex]];
            // å¹¶è®¾ç½®ä¸ºdequeuedCell
            self.dequeuedCell = (UITableViewCell *)[self viewWithTag:CMTTableScrollViewBaseCellTag + previousIndex];
        }
    }
    
    // when cell's width is small , during fast scrolling , scrollview looses cells to display. In this case self.lostCells is set to 'YES' . Need to work on this more. Called when [self.indexsOfVisibleCells count]<=0
    else {
        self.lostCells = YES;
//        CMTLogError(@"lostCells happen");
    }
}

#pragma mark - Lost

// å¯»æ¾åºè¯¥æ¾ç¤º ä½æ²¡ææ¾ç¤ºçcell
- (void)findLostCells {
    BOOL found = NO;
    
    for (NSInteger index = 0; index < self.numberOfCells; index++) {
        
        // å¯»æ¾åºè¯¥æ¾ç¤ºçcell
        CGRect frameOfCell = [self frameOfCellAtIndex:index];
        if (CGRectIntersectsRect(self.bounds, frameOfCell) == YES) {
            
            // åºè¯¥æ¾ç¤ºä½æ²¡ææ¾ç¤ºçcell
            if ([self.indexsOfVisibleCells containsObject:[NSNumber numberWithInteger:index]] == NO) {
                // cellå¯¹åºindexå å¥indexsOfVisibleCells
                [self.indexsOfVisibleCells addObject:[NSNumber numberWithInteger:index]];
                found = YES;
            }
        }
        else if (found == YES) {
            [self retrieveLostCells];
            return;
        }
    }
    // å·æ°éè¦æ¾ç¤ºçcell
    if (found == YES) {
        [self retrieveLostCells];
    }
}

// å·æ°ææéè¦æ¾ç¤ºçcellçframeç­
- (void)retrieveLostCells {
    // éåéè¦æ¾ç¤ºçcellçindex
    for (NSInteger index = 0; index < self.indexsOfVisibleCells.count; index++) {
        // è·åcell
        NSInteger cellIndex = [[self.indexsOfVisibleCells objectAtIndex:index] integerValue];
        UITableViewCell *cell = [self.tableScrollViewDataSource tableScrollView:self cellAtIndex:cellIndex];
        // å·æ°cellçframe
        cell.frame = [self frameOfCellAtIndex:cellIndex];
        // å·æ°cellçtag
        cell.tag = CMTTableScrollViewBaseCellTag + cellIndex;
        
        // å¦æcellæ¯æ°çæç è¿æ²¡ææ·»å å°UIScrollViewä¸
        // å°cellæ·»å å°UIScrollViewä¸ å¹¶ æ·»å ç¸åºç¹å»äºä»¶
        if ([self viewWithTag:cell.tag] == nil) {
            
            // æ·»å cell
            [self insertSubview:cell aboveSubview:self.blackCoverView];
            
            // æ·»å cellç¹å»æå¿
            if (cell.gestureRecognizers.count > 0) {
                for (UIGestureRecognizer *gestureRecognizer in cell.gestureRecognizers) {
                    gestureRecognizer.delegate = nil;
                    [cell removeGestureRecognizer:gestureRecognizer];
                }
            }
            if ([cell isKindOfClass:[CMTReplyListWrapCell class]] == NO) {
                CMTTableScrollViewCellTapGesture *tapGestureRecognizer = [[CMTTableScrollViewCellTapGesture alloc] initWithTarget:self action:@selector(handleTap:)];
                tapGestureRecognizer.delegate = tapGestureRecognizer;
                [cell addGestureRecognizer:tapGestureRecognizer];
            }
        }
        else {
            // to do
        }
        
        // è°ç¨delegate -willDisplayCell
        if ([self.tableScrollViewDelegate respondsToSelector:@selector(tableScrollView:willDisplayCell:atIndex:)]) {
            [self.tableScrollViewDelegate tableScrollView:self willDisplayCell:cell atIndex:cellIndex];
        }
    }
}

#pragma mark - ScrollView

- (void)tableScrollViewDidScroll:(UIScrollView *)scrollView {
    if (self.afterReload == NO) {
        return;
    }
    
//    if (self.lostCells == YES && self.cellLostExpected == NO) {
//        
//        [self findLostCells];
//        self.lostCells = NO;
//    }
    
    // å¯»æ¾åºè¯¥æ¾ç¤º ä½æ²¡ææ¾ç¤ºçcell
    [self findLostCells];
    self.lostCells = NO;

    // scrollViewä¸æ»/ä¸æ»
    [self inqueueReusableCellWithForwardDirection:(scrollView.bounds.origin.y - self.headerHeight) > self.currentOffsetY];
    self.currentOffsetY = (scrollView.bounds.origin.y - self.headerHeight);
}


- (void)tableScrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView {
    if (self.afterReload == NO) {
        return;
    }

//    if (self.lostCells == YES) {
//        
//        [self findLostCells];
//        self.lostCells = NO;
//    }
//    
//    self.cellLostExpected = NO;
    
    // scroll Animation ä¹åä¼ä¸¢å¤±cell æä»¥éæ°å è½½ææcell
    [self reloadScrollData];
}

- (void)tableScrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {
    if (self.afterReload == NO) {
        return;
    }

    if (decelerate == NO) {
        // ç§»é¤ä¸åºæ¾ç¤º ä½ä»å¨UIScrollViewä¸çcell
        [self removeAliveOutOfBoundsCells];
    }
}

- (void)tableScrollViewDidEndDecelerating:(UIScrollView *)scrollView {
    if (self.afterReload == NO) {
        return;
    }

    // ç§»é¤ä¸åºæ¾ç¤º ä½ä»å¨UIScrollViewä¸çcell
    [self removeAliveOutOfBoundsCells];
}

// ç§»é¤ä¸åºæ¾ç¤º ä½ä»å¨UIScrollViewä¸çcell
- (void)removeAliveOutOfBoundsCells {
    UIView __weak *dequedCell = nil;
    UIView __weak *otherView = nil;
    
    // éåUIScrollViewä¸çcell
    for (UITableViewCell *cell in self.subviews) {
        if ([cell isKindOfClass:[UITableViewCell class]]) {
            // ä¸åºæ¾ç¤ºçcell
            if (CGRectIntersectsRect(self.bounds, cell.frame) == NO) {
                // æ­¤cellä¸ä¸ºå¤ç¨cell
                if ([cell isEqual:self.dequeuedCell] == NO) {
                    // æ»cellæ°å¤§äº1
                    if (self.numberOfCells > 1) {
                        // ç§»é¤æ­¤ä¸åºæ¾ç¤ºçcell
                        [cell removeFromSuperview];
                    }
                    // cellæ°éä¸º1
                    else {
                        // ä¸´æ¶è·åæ­¤cell çæ¯å¦éè¦ç§»é¤
                        otherView = cell;
                    }
                }
                // æ­¤cellä¸ºå¤ç¨cell
                else {
                    dequedCell = cell;
                }
            }
        }
    }
    
    // å¦æå¤ç¨çcellå­å¨ åç§»é¤ä¸´æ¶è·åçcell
    if (dequedCell != nil) {
        [otherView removeFromSuperview];
    }
}

#pragma mark - Gesture

- (void)handleTap:(CMTTableScrollViewCellTapGesture *)recognizer {
//    NSNumber *index = [self indexOfLocation:[recognizer locationInView:self]];
//    if (index != nil) {
//        [self didSelectedItemAtIndex:index];
//    }
    
    NSInteger index = recognizer.view.tag - CMTTableScrollViewBaseCellTag;
    if (0 <= index && index < self.numberOfCells) {
        [self didSelectedItemAtIndex:[NSNumber numberWithInteger:index]];
    }
}

- (NSNumber *)indexOfLocation:(CGPoint)location {
    NSNumber *index = nil;
    
    for (NSInteger cellIndex = 0; cellIndex < self.numberOfCells; cellIndex++) {
        CGRect cellFrame = [self frameOfCellAtIndex:cellIndex];
        if (CGRectContainsPoint(cellFrame, location)) {
            index = [NSNumber numberWithInteger:cellIndex];
            break;
        }
    }
    
    return index;
}

- (void)didSelectedItemAtIndex:(NSNumber *)index {
    if ([self.tableScrollViewDelegate respondsToSelector:@selector(tableScrollView:didSelectCellAtIndex:)]) {
        [self.tableScrollViewDelegate tableScrollView:self didSelectCellAtIndex:index.integerValue];
    }
}

@end

